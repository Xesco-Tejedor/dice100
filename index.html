<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Dado D100 3D</title>
  <style>
    body { margin: 0; overflow: hidden; }
    #overlay {
      position: fixed;
      top:0; left:0; width:100vw; height:100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
      z-index: 10;
    }
    #resultFace {
      font-size: 6em;
      color: #fff;
      text-shadow: 0 0 30px #000, 0 0 10px #000;
      display: none;
    }
  </style>
</head>
<body>
  <div id="overlay"><span id="resultFace"></span></div>
  <script src="https://cdn.jsdelivr.net/npm/three@0.156.1/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js"></script>
  <script>
    // --- Three.js scene setup ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x202035);
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 5, 14);

    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Room (cube)
    const roomSize = 10;
    const cube = new THREE.Mesh(
      new THREE.BoxGeometry(roomSize, roomSize, roomSize),
      new THREE.MeshBasicMaterial({color:0x404050, wireframe:true})
    );
    cube.position.y = roomSize/2;
    scene.add(cube);

    // --- Cannon-es physics world ---
    const world = new CANNON.World({
      gravity: new CANNON.Vec3(0, -9.82, 0)
    });

    // Room walls (static)
    const half = roomSize/2;
    for (let i=0; i<6; ++i) {
      const plane = new CANNON.Body({mass:0});
      switch(i){
        case 0: plane.addShape(new CANNON.Plane()); plane.position.set(0, 0, half); break;      // back
        case 1: plane.addShape(new CANNON.Plane()); plane.position.set(0, 0, -half); plane.quaternion.setFromEuler(0, Math.PI, 0); break; // front
        case 2: plane.addShape(new CANNON.Plane()); plane.position.set(half, 0, 0); plane.quaternion.setFromEuler(0, -Math.PI/2, 0); break; // right
        case 3: plane.addShape(new CANNON.Plane()); plane.position.set(-half, 0, 0); plane.quaternion.setFromEuler(0, Math.PI/2, 0); break; // left
        case 4: plane.addShape(new CANNON.Plane()); plane.position.set(0, roomSize, 0); plane.quaternion.setFromEuler(-Math.PI/2, 0, 0); break; // top
        case 5: plane.addShape(new CANNON.Plane()); plane.position.set(0, 0, 0); plane.quaternion.setFromEuler(Math.PI/2, 0, 0); break; // bottom
      }
      world.addBody(plane);
    }

    // D100 (visual: sphere for now)
    const d100Radius = 1.2;
    const geometry = new THREE.SphereGeometry(d100Radius, 32, 32);
    const material = new THREE.MeshPhongMaterial({color: 0xb3e9ff, shininess:80});
    const d100 = new THREE.Mesh(geometry, material);
    scene.add(d100);

    // D100 physics
    const d100Body = new CANNON.Body({
      mass: 1,
      shape: new CANNON.Sphere(d100Radius),
      position: new CANNON.Vec3(0, roomSize-2, 0),
      angularDamping: 0.2,
      linearDamping: 0.15
    });
    world.addBody(d100Body);

    // Light
    const light = new THREE.PointLight(0xffffff, 2, 100);
    light.position.set(0, roomSize, 10);
    scene.add(light);

    // Overlay for result
    const overlay = document.getElementById("overlay");
    const resultFace = document.getElementById("resultFace");

    // "Launch" the die with random force & torque
    function launchDie() {
      d100Body.position.set(
        (Math.random()-0.5)*3,
        roomSize-2,
        (Math.random()-0.5)*3
      );
      d100Body.velocity.set(
        (Math.random()-0.5)*14,
        Math.random()*8 + 5,
        (Math.random()-0.5)*14
      );
      d100Body.angularVelocity.set(
        (Math.random()-0.5)*25,
        (Math.random()-0.5)*25,
        (Math.random()-0.5)*25
      );
      resultFace.style.display = "none";
    }

    launchDie();

    // Animation loop
    let stopped = false;
    function animate() {
      requestAnimationFrame(animate);
      world.step(1/60);

      // Sync physics and rendering
      d100.position.copy(d100Body.position);
      d100.quaternion.copy(d100Body.quaternion);

      // Detect stop (low velocity & angular velocity)
      if (!stopped &&
          d100Body.velocity.length() < 0.1 &&
          d100Body.angularVelocity.length() < 0.1 &&
          d100Body.position.y < roomSize/2 + d100Radius + 0.1
      ) {
        stopped = true;
        setTimeout(showResult, 900);
      }

      renderer.render(scene, camera);
    }

    animate();

    function showResult() {
      // Pick a random face (simulate actual orientation)
      const face = Math.floor(Math.random()*100)+1;
      resultFace.textContent = face;
      resultFace.style.display = "block";
      // Animate: scale up result
      resultFace.animate([
        {transform:'scale(0.1)'},
        {transform:'scale(1.5)'},
        {transform:'scale(1)'},
      ], {
        duration: 600,
        easing: 'cubic-bezier(.42,2,.58,.8)'
      });
    }

    // Click to relaunch
    window.addEventListener('click', () => {
      if (stopped) {
        stopped = false;
        launchDie();
      }
    });

    // Responsive
    window.addEventListener('resize',()=>{
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
