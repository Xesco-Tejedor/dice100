<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Dado D100 3D</title>
  <style>
    body { margin: 0; overflow: hidden; background: #202035; }
    #overlay {
      position: fixed;
      top:0; left:0; width:100vw; height:100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
      z-index: 10;
    }
    #resultFace {
      font-size: 6em;
      color: #fff;
      text-shadow: 0 0 30px #000, 0 0 10px #000;
      display: none;
    }
  </style>
</head>
<body>
  <div id="overlay"><span id="resultFace"></span></div>
  <script src="https://cdn.jsdelivr.net/npm/three@0.156.1/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js"></script>
  <script>
    // --- Three.js scene setup ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x202035);
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 10, 18);

    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Room (cube)
    const roomSize = 12;
    const half = roomSize/2;
    // Visual cube (edges)
    const edges = new THREE.EdgesGeometry(new THREE.BoxGeometry(roomSize, roomSize, roomSize));
    const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x4040a0 }));
    scene.add(line);

    // Move cube and camera so bottom is at y=0
    line.position.y = half;
    camera.lookAt(0, half, 0);

    // --- Cannon-es physics world ---
    const world = new CANNON.World({
      gravity: new CANNON.Vec3(0, -15, 0)
    });

    // Room walls (static) - properly aligned with cube
    function addWall({position, rotation}) {
      const wall = new CANNON.Body({mass: 0});
      wall.addShape(new CANNON.Plane());
      wall.position.set(...position);
      if(rotation) wall.quaternion.setFromEuler(...rotation);
      world.addBody(wall);
    }
    // Floor (y=0)
    addWall({position: [0, 0, 0], rotation: [ -Math.PI/2, 0, 0 ]});
    // Ceiling (y=roomSize)
    addWall({position: [0, roomSize, 0], rotation: [ Math.PI/2, 0, 0 ]});
    // +Z wall (back)
    addWall({position: [0, half, half], rotation: [0, 0, 0]});
    // -Z wall (front)
    addWall({position: [0, half, -half], rotation: [0, Math.PI, 0]});
    // +X wall (right)
    addWall({position: [half, half, 0], rotation: [0, -Math.PI/2, 0]});
    // -X wall (left)
    addWall({position: [-half, half, 0], rotation: [0, Math.PI/2, 0]});

    // D100 (visual: sphere for now)
    const d100Radius = 1.3;
    const geometry = new THREE.SphereGeometry(d100Radius, 64, 64);
    const material = new THREE.MeshPhongMaterial({color: 0xb3e9ff, shininess:80});
    const d100 = new THREE.Mesh(geometry, material);
    d100.castShadow = true;
    d100.receiveShadow = true;
    scene.add(d100);

    // D100 physics
    const d100Body = new CANNON.Body({
      mass: 1,
      shape: new CANNON.Sphere(d100Radius),
      position: new CANNON.Vec3(0, roomSize-2, 0),
      angularDamping: 0.23,
      linearDamping: 0.18
    });
    world.addBody(d100Body);

    // Light
    const light = new THREE.PointLight(0xffffff, 2, 100);
    light.position.set(0, roomSize*1.1, 10);
    scene.add(light);

    // Ambient light for softer shading
    scene.add(new THREE.AmbientLight(0xccccff, 0.6));

    // Overlay for result
    const overlay = document.getElementById("overlay");
    const resultFace = document.getElementById("resultFace");

    // "Launch" the die with random force & torque
    function launchDie() {
      d100Body.velocity.set(0,0,0);
      d100Body.angularVelocity.set(0,0,0);
      d100Body.position.set(
        (Math.random()-0.5)*5,
        roomSize-2,
        (Math.random()-0.5)*5
      );
      d100Body.velocity.set(
        (Math.random()-0.5)*12,
        Math.random()*8 + 8,
        (Math.random()-0.5)*12
      );
      d100Body.angularVelocity.set(
        (Math.random()-0.5)*18,
        (Math.random()-0.5)*18,
        (Math.random()-0.5)*18
      );
      resultFace.style.display = "none";
      stopped = false;
    }

    launchDie();

    // Animation loop
    let stopped = false;
    function animate() {
      requestAnimationFrame(animate);
      world.step(1/60);

      // Sync physics and rendering
      d100.position.copy(d100Body.position);
      d100.quaternion.copy(d100Body.quaternion);

      // Detect stop (low velocity & angular velocity, and near the floor)
      if (!stopped &&
          d100Body.velocity.length() < 0.13 &&
          d100Body.angularVelocity.length() < 0.12 &&
          d100Body.position.y < (roomSize - 1.8)
      ) {
        stopped = true;
        setTimeout(showResult, 900);
      }

      renderer.render(scene, camera);
    }

    animate();

    function showResult() {
      // Pick a random face (simulate actual orientation)
      const face = Math.floor(Math.random()*100)+1;
      resultFace.textContent = face;
      resultFace.style.display = "block";
      // Animate: scale up result
      resultFace.animate([
        {transform:'scale(0.1)'},
        {transform:'scale(1.5)'},
        {transform:'scale(1)'},
      ], {
        duration: 600,
        easing: 'cubic-bezier(.42,2,.58,.8)'
      });
    }

    // Click to relaunch
    window.addEventListener('click', () => {
      if (stopped) {
        launchDie();
      }
    });

    // Responsive
    window.addEventListener('resize',()=>{
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
