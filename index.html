<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Dado D100 3D</title>
  <style>
    body { margin: 0; overflow: hidden; background: #202035; }
    #overlay {
      position: fixed;
      top:0; left:0; width:100vw; height:100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
      z-index: 10;
    }
    #resultFace {
      font-size: 6em;
      color: #fff;
      text-shadow: 0 0 30px #000, 0 0 10px #000;
      display: none;
    }
  </style>
</head>
<body>
  <div id="overlay"><span id="resultFace"></span></div>
  <script src="https://cdn.jsdelivr.net/npm/three@0.156.1/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js"></script>
  <script>
    // --- Three.js scene setup ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x202035);
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
    const roomSize = 12;
    const half = roomSize / 2;
    camera.position.set(0, half, roomSize * 1.5);
    camera.lookAt(0, half, 0);

    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Visual cube (edges)
    const edges = new THREE.EdgesGeometry(new THREE.BoxGeometry(roomSize, roomSize, roomSize));
    const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x4040a0 }));
    line.position.y = half;
    scene.add(line);

    // --- Cannon-es physics world ---
    const world = new CANNON.World({ gravity: new CANNON.Vec3(0, -15, 0) });

    // Room walls (static) - perfectly match the visual cube
    function addWall(pos, quat) {
      const wall = new CANNON.Body({mass: 0, shape: new CANNON.Plane()});
      wall.position.set(...pos);
      if (quat) wall.quaternion.setFromEuler(...quat);
      world.addBody(wall);
    }
    // Floor
    addWall([0, 0, 0], [ -Math.PI/2, 0, 0 ]);
    // Ceiling
    addWall([0, roomSize, 0], [ Math.PI/2, 0, 0 ]);
    // Back wall (z+)
    addWall([0, half, half], [0, 0, 0]);
    // Front wall (z-)
    addWall([0, half, -half], [0, Math.PI, 0]);
    // Right wall (x+)
    addWall([half, half, 0], [0, -Math.PI/2, 0]);
    // Left wall (x-)
    addWall([-half, half, 0], [0, Math.PI/2, 0]);

    // D100 (visual: sphere for now)
    const d100Radius = 1.3;
    const geometry = new THREE.SphereGeometry(d100Radius, 64, 64);
    const material = new THREE.MeshPhongMaterial({color: 0xb3e9ff, shininess:80});
    const d100 = new THREE.Mesh(geometry, material);
    scene.add(d100);

    // D100 physics
    const d100Body = new CANNON.Body({
      mass: 1,
      shape: new CANNON.Sphere(d100Radius),
      position: new CANNON.Vec3(0, roomSize - 2, 0),
      angularDamping: 0.23,
      linearDamping: 0.18
    });
    world.addBody(d100Body);

    // Light
    const light = new THREE.PointLight(0xffffff, 2, 100);
    light.position.set(0, roomSize * 1.3, roomSize * 1.3);
    scene.add(light);

    // Ambient light
    scene.add(new THREE.AmbientLight(0xccccff, 0.6));

    // Overlay for result
    const resultFace = document.getElementById("resultFace");

    // "Launch" the die with random force & torque
    function launchDie() {
      d100Body.velocity.set(0,0,0);
      d100Body.angularVelocity.set(0,0,0);
      d100Body.position.set(
        (Math.random()-0.5)*4,
        roomSize - 3,
        (Math.random()-0.5)*4
      );
      d100Body.velocity.set(
        (Math.random()-0.5)*12,
        Math.random()*8 + 8,
        (Math.random()-0.5)*12
      );
      d100Body.angularVelocity.set(
        (Math.random()-0.5)*18,
        (Math.random()-0.5)*18,
        (Math.random()-0.5)*18
      );
      resultFace.style.display = "none";
      stopped = false;
    }

    launchDie();

    // Animation loop
    let stopped = false;
    function animate() {
      requestAnimationFrame(animate);
      world.step(1/60);

      // Sync physics and rendering
      d100.position.copy(d100Body.position);
      d100.quaternion.copy(d100Body.quaternion);

      // Detect stop (low velocity & angular velocity, and near the floor)
      if (!stopped &&
          d100Body.velocity.length() < 0.13 &&
          d100Body.angularVelocity.length() < 0.12 &&
          d100Body.position.y < (roomSize - 1.8)
      ) {
        stopped = true;
        setTimeout(showResult, 900);
      }

      renderer.render(scene, camera);
    }

    animate();

    function showResult() {
      // Pick a random face (simulate actual orientation)
      const face = Math.floor(Math.random()*100)+1;
      resultFace.textContent = face;
      resultFace.style.display = "block";
      // Animate: scale up result
      resultFace.animate([
        {transform:'scale(0.1)'},
        {transform:'scale(1.5)'},
        {transform:'scale(1)'},
      ], {
        duration: 600,
        easing: 'cubic-bezier(.42,2,.58,.8)'
      });
    }

    // Click to relaunch
    window.addEventListener('click', () => {
      if (stopped) {
        launchDie();
      }
    });

    // Responsive
    window.addEventListener('resize',()=>{
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
